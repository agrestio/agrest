<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
   <title xmlns:d="http://docbook.org/ns/docbook">Chapter&nbsp;13.&nbsp;Request Chains</title><link rel="stylesheet" type="text/css" href="css/doc.css"><meta xmlns:d="http://docbook.org/ns/docbook" name="keywords" content="LinkRest 1 documentation"><meta xmlns:d="http://docbook.org/ns/docbook" name="description" content="User documentation for LinkRest version 1"><link rel="home" href="index.html" title="LinkRest Guide"><link rel="up" href="framework.html" title="Part&nbsp;III.&nbsp;LinkRest Framework"><link rel="prev" href="framework-programming-endpoints.html" title="Chapter&nbsp;12.&nbsp;Writing Resource Endpoints"><link rel="next" href="framework-pojo.html" title="Chapter&nbsp;14.&nbsp;Non-Persistent Properties"><script xmlns:d="http://docbook.org/ns/docbook" type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-67243676-1', 'auto');
  ga('send', 'pageview');
        </script></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div xmlns:d="http://docbook.org/ns/docbook" class="navheader"><table width="100%" summary="Navigation header"><tr><th class="versioninfo">v.1 (1.19-SNAPSHOT)</th><th align="center">Chapter&nbsp;13.&nbsp;Request Chains</th><th></th></tr><tr><td width="20%" align="left"><a accesskey="p" href="framework-programming-endpoints.html">Prev</a>&nbsp;</td><th width="60%" align="center"><a accesskey="u" href="framework.html">Part&nbsp;III.&nbsp;LinkRest Framework</a></th><td width="20%" align="right">&nbsp;<a accesskey="n" href="framework-pojo.html">Next</a></td></tr></table><hr></div><div class="chapter" title="Chapter&nbsp;13.&nbsp;Request Chains"><div class="titlepage"><div><div><h2 class="title"><a name="framework-chains"></a>Chapter&nbsp;13.&nbsp;Request Chains</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="framework-chains.html#framework-chains-available">Available Chains</a></span></dt><dt><span class="section"><a href="framework-chains.html#framework-chains-mapper">Strategies for Object Matching</a></span></dt><dt><span class="section"><a href="framework-chains.html#framework-chains-idempotency">Idempotency of Updating Chains</a></span></dt></dl></div><div class="section" title="Available Chains"><div class="titlepage"><div><div><h2 class="title"><a name="framework-chains-available"></a>Available Chains</h2></div></div></div><p>As demonstrated by earlier examples, to process a given request you need to build an
      appropriate LinkRest "chain". Each chain starts with a call to a static method of LinkRest
      class, that determines chain type, parameters it can take, and the type of response it
      generates. Each chain type naturally maps to a single HTTP method. Although ultimately the
      mapping of chains to methods is not enforced by LinkRest and is left to the application
      developer. The following chains are available:
      </p><pre class="programlisting">// use with @GET
LinkRest.select(SomeEntity.class, config)...

// use with @DELETE
LinkRest.delete(SomeEntity.class, config)...

// use with @POST
LinkRest.create(SomeEntity.class, config)...

// use with @POST
LinkRest.createOrUpdate(SomeEntity.class, config)...

// use with @PUT
LinkRest.idempotentCreateOrUpdate(SomeEntity.class, config)...

// use with @PUT
LinkRest.idempotentFullSync(SomeEntity.class, config)...

// use with @GET for metadata endpoints
LinkRest.metadata(SomeEntity.class, config)...</pre></div><div class="section" title="Strategies for Object Matching"><div class="titlepage"><div><div><h2 class="title"><a name="framework-chains-mapper"></a>Strategies for Object Matching</h2></div></div></div><p>Many of the updating chains need to match objects coming as Update Documents (see <a class="xref" href="protocol-json-documents.html#protocol-update-document" title="Request: Update Document">the section called &#8220;Request: Update Document&#8221;</a>) against  objects in the database. E.g.
      "createOrUpdate" needs to know whether a JSON object is new (and needs to be created) or it
      already exists (and needs to be updated). By default LinkRest would attempt to match each JSON
      "id" attribute with a DB record primary key. This is a reasonable and useful strategy. Its
      main limitation though - it can't be used for entities with ids generated on the server when
      combined with idempotent requests (see the next section on idempotency). To work around this
      limitation one may use a meaningful unique property that is known to the client at the object
      creation time. E.g. our Domain entity has a unique property "vhost".  </p><p>To ensure the chain uses a property other than "id" for matching, a user may should set an
      explicit mapper on the
        chain:</p><pre class="programlisting">LinkRest.idempotentCreateOrUpdate(Domain.class, config)
    .mapper(ByKeyObjectMapperFactory.byKey(Domain.VHOST))
    .sync(entityData);</pre><p><code class="code">ByKeyObjectMapperFactory</code>
      mapper is provided by LinkRest. If something other than mapping by property is needed, a
      custom <code class="code">ObjectMapperFactory</code> can be coded by the user.</p></div><div class="section" title="Idempotency of Updating Chains"><div class="titlepage"><div><div><h2 class="title"><a name="framework-chains-idempotency"></a>Idempotency of Updating Chains</h2></div></div></div><p>It is easy to distinguish updating chains that are idempotent from those that are not
      (chain factory method starts with "idempotent" for the former). Both work the same way, except
      that "idempotent" ones perform an extra check on the input to ensure that it is repeatable,
      i.e. it will be safe to run it multiple times with the same effect as running it once. At the
      minimum this means that all the "new" objects have their ids set in the request. This is where
        <code class="code">ByKeyObjectMapperFactory</code> discussed above comes in handy. Pretty much all
      idempotent chains need to use <code class="code">ByKeyObjectMapperFactory</code> or an equivalent mapper to
      match by some unique property of the entity, that is known to the client at the object
      creation time.</p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="framework-programming-endpoints.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="framework.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="framework-pojo.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;12.&nbsp;Writing Resource Endpoints&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;14.&nbsp;Non-Persistent Properties</td></tr></table></div></body></html>